<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>conda命令</title>
    <url>/2019/12/conda%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>一些常用的conda命令总结</p>
<span id="more"></span>

<h1 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h1><ol>
<li><p>查看当前存在哪些虚拟环境（当前被激活的环境会显示有一个星号或者括号。）</p>
<pre><code> conda env list 或者 conda info -e
</code></pre>
</li>
<li><p>创建一个名为ml的环境，同时指定python版本为3.x（conda会自动寻找3.x中最新的版本）</p>
<pre><code> conda create --name ml python=3.x
</code></pre>
</li>
<li><p>激活某个环境</p>
<pre><code> activate ml # for Wins
 source activate ml # for Linux or Mac
</code></pre>
</li>
<li><p>返回默认的环境</p>
<pre><code> deactivate ml # for Wins
 source deactivate ml # for Linux or Mac
</code></pre>
</li>
<li><p>删除一个已有的环境 </p>
<pre><code> conda remove --name ml --all
</code></pre>
</li>
</ol>
<h1 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h1><ol>
<li><p>安装包</p>
<pre><code> conda install -n ml numpy
</code></pre>
<p> 如果不用-n指定环境名称，则被安装在当前活跃环境，也可以通过-c指定通过某个channel安装</p>
</li>
<li><p>更新包</p>
<pre><code> conda update -n ml numpy
</code></pre>
</li>
<li><p>删除包</p>
<pre><code> conda remove -n ml numpy
</code></pre>
</li>
<li><p>查看当前环境下已安装的包</p>
<pre><code> conda list
</code></pre>
</li>
<li><p>查看某个指定环境的已安装包</p>
<pre><code> conda list -n ml
</code></pre>
</li>
<li><p>查找package信息</p>
<pre><code> conda search numpy
</code></pre>
</li>
<li><p>conda将conda、python等都视为package，因此，完全可以使用conda来管理conda和python的版本，例如</p>
<pre><code> # 更新conda，保持conda最新
 conda update conda
 # 更新anaconda
 conda update anaconda     
 # 更新python
 conda update python
 
</code></pre>
</li>
</ol>
<h1 id="设置国内镜像"><a href="#设置国内镜像" class="headerlink" title="设置国内镜像"></a>设置国内镜像</h1><ol>
<li><p>我使用的清华的Anaconda仓库的镜像</p>
<pre><code> conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
</code></pre>
</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol>
<li><p>使jupyter支持虚拟运行环境：</p>
<pre><code> conda install nb_conda
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>conda</category>
      </categories>
      <tags>
        <tag>conda</tag>
      </tags>
  </entry>
  <entry>
    <title>圣诞快乐</title>
    <url>/2019/12/%E5%9C%A3%E8%AF%9E%E5%BF%AB%E4%B9%90/</url>
    <content><![CDATA[<p>Happy Christmas to u, my xia!</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>with xla</tag>
      </tags>
  </entry>
  <entry>
    <title>序</title>
    <url>/2019/12/%E5%BA%8F/</url>
    <content><![CDATA[<!-- # <center>序</center> -->

<p>　　如果说人生是一本书，那么这本书应该有一个序章。</p>
<p>　　在19年的尾巴，我终于决定搭建我拖延了很久的博客，然后给我的人生写一篇序章。这说的仿佛我的人生才刚开始一样，然而的确，我的人生应该有一个新的开始。</p>
<p>　　我以前是一个很懒的人，自从高中毕业后，就很少会动笔去记录一些东西，平凡的生活，日常的感触，技术的成长，学习的过程。所以到现在我回想过去学到了什么，就只有散落在各处零散的笔记，以及更多我曾思考过解决过却没有记录下来的问题。</p>
<p>　　从今天开始，就做一个学徒途径的记录官吧（《诡秘之主》赛高），我来过，我见过，我记录。</p>
]]></content>
  </entry>
  <entry>
    <title>pytorch从入门到放弃(1)</title>
    <url>//pytorch-learning-1.html</url>
    <content><![CDATA[<p>test</p>
]]></content>
      <categories>
        <category>编程</category>
        <category>AI</category>
        <category>pytroch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>mac xcrun: error: invalid active developer path错误</title>
    <url>//xcrun-error</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>今天使用git命令时报下面的错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), </span><br><span class="line">missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</span><br></pre></td></tr></table></figure>

<h1 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h1><p>macOS升级导致的<code>Xcode command line tools</code>丢失引起的，每次macOS更新，xcode命令行工具总被卸载掉，必须重新下载安装😅</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">$ xcode-<span class="keyword">select</span> <span class="comment">--install</span></span><br><span class="line">xcode-<span class="keyword">select</span>: <span class="literal">note</span>: install requested <span class="keyword">for</span> command <span class="literal">line</span> developer tools</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>PAT (甲级) 1036 Boys vs Girls (25分)</title>
    <url>//1036.html</url>
    <content><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题:"></a><font color=#0099ff size=4 face="黑体">原题:</font></h1><p>This time you are asked to tell the difference between the lowest grade of all the male students and the highest grade of all the female students.</p>
<p><font size=4>Input Specification:</font></p>
<p>Each input file contains one test case. Each case contains a positive integer N, followed by N lines of student information. Each line contains a student’s name, gender, ID and grade, separated by a space, where name and ID are strings of no more than 10 characters with no space, gender is either F (female) or M (male), and grade is an integer between 0 and 100. It is guaranteed that all the grades are distinct.</p>
<p><font size=4>Output Specification:</font></p>
<p>For each test case, output in 3 lines. The first line gives the name and ID of the female student with the highest grade, and the second line gives that of the male student with the lowest grade. The third line gives the difference <em>gradeF − gradeM</em>. If one such kind of student is missing, output Absent in the corresponding line, and output NA in the third line instead.</p>
<p><font size=4>Sample Input 1:</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">Joe M Math990112 89</span><br><span class="line">Mike M CS991301 100</span><br><span class="line">Mary F EE990830 95</span><br></pre></td></tr></table></figure>

<p><font size=4>Sample Output 1:</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mary EE990830</span><br><span class="line">Joe Math990112</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<p><font size=4>Sample Input 2:</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">Jean M AA980920 60</span><br></pre></td></tr></table></figure>
<p><font size=4>Sample Output 2:</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Absent</span><br><span class="line">Jean AA980920</span><br><span class="line">NA</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a><font color=#0099ff size=4 face="黑体">题目大意:</font></h1><p>　　给定N组学生信息，输出女生中的最高分获得者的信息与男生中最低分获得者的信息，并输出他们的分数差。如果不存在女生或者男生，则对应获得者信息处输出Absent，同时差值处输出NA。</p>
<h1 id="题目分类"><a href="#题目分类" class="headerlink" title="题目分类:"></a><font color=#0099ff size=4 face="黑体">题目分类:</font></h1><p>　　简单模拟</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路:"></a><font color=#0099ff size=4 face="黑体">思路:</font></h1><p>　　使用字符数组<em>max_f_name</em>,<em>max_f_ID</em>表示女生最高分学生的信息，<em>min_m_name</em>, <em>min_m_ID</em>表示男生最低分学生的信息，在输入的时候比较并更新最高/低分，同时记录对应学生的信息。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a><font color=#0099ff size=4 face="黑体">注意事项:</font></h1><ol>
<li><p>表示name，ID的char数组的大小必须要大于10，如果设置10，提交时会出现“运行时错误”的问题。（这个问题应该在于c中char数组的大小应该等于元素数+1，因为要存终止符 ‘\0’ ）</p>
</li>
<li><p>初值最低分max_grade_f = -1, 最高分min_grade_m = 101，这样可以直接根据初值来判断是否出现过男生或者女生。不用另外使用bool值来判断（另外，c中是没有bool变量的）</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码:"></a><font color=#0099ff size=4 face="黑体">代码:</font></h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n, grade, max_grade_f = <span class="number">-1</span>, min_grade_m = <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">11</span>], gender, ID[<span class="number">11</span>], max_f_name[<span class="number">11</span>], max_f_ID[<span class="number">11</span>], min_m_name[<span class="number">11</span>], min_m_ID[<span class="number">11</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %c %s %d&quot;</span>, name, &amp;gender, ID, &amp;grade);</span><br><span class="line">        <span class="keyword">if</span>(gender == <span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//男生</span></span><br><span class="line">            <span class="keyword">if</span>(grade &lt; min_grade_m)&#123;</span><br><span class="line">                min_grade_m = grade;</span><br><span class="line">                <span class="built_in">strcpy</span>(min_m_name, name);</span><br><span class="line">                <span class="built_in">strcpy</span>(min_m_ID, ID);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(gender == <span class="string">&#x27;F&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//女生</span></span><br><span class="line">            <span class="keyword">if</span>(grade &gt; max_grade_f)&#123;</span><br><span class="line">                max_grade_f = grade;</span><br><span class="line">                <span class="built_in">strcpy</span>(max_f_name, name);</span><br><span class="line">                <span class="built_in">strcpy</span>(max_f_ID, ID);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(max_grade_f == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Absent\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>, max_f_name, max_f_ID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(min_grade_m == <span class="number">101</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Absent\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>, min_m_name, min_m_ID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(max_grade_f == <span class="number">-1</span> <span class="keyword">or</span> min_grade_m == <span class="number">101</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NA&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, max_grade_f - min_grade_m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
        <category>PAT</category>
        <category>Advanced</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT (甲级) 1004 Counting Leaves (30分)</title>
    <url>//1004.html</url>
    <content><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题:"></a><font color=#0099ff size=4 face="黑体">原题:</font></h1><p>A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child.</p>
<p><font size=4>Input Specification:</font></p>
<p>Each input file contains one test case. Each case starts with a line containing 0&lt;N&lt;100, the number of nodes in a tree, and M (&lt;N), the number of non-leaf nodes. Then M lines follow, each in the format:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ID K ID[1] ID[2] ... ID[K]</span><br></pre></td></tr></table></figure>

<p>where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID’s of its children. For the sake of simplicity, let us fix the root ID to be 01.</p>
<p>The input ends with N being 0. That case must NOT be processed.</p>
<p><font size=4>Output Specification:</font></p>
<p>For each test case, you are supposed to count those family members who have no child for every seniority level starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line.</p>
<p>The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node. Then we should output 0 1 in a line.</p>
<p><font size=4>Sample Input:</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">01 1 02</span><br></pre></td></tr></table></figure>

<p><font size=4>Sample Output:</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a><font color=#0099ff size=4 face="黑体">题目大意:</font></h1><p>　　给定一个家庭族谱，统计家庭中没有孩子的家庭成员人数</p>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类:"></a><font color=#0099ff size=4 face="黑体">分类:</font></h1><p>　　树</p>
<h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路:"></a><font color=#0099ff size=4 face="黑体">题目思路:</font></h1><p>　　题目给定的是普通树，将其转化为孩子——兄弟的二叉树。同时注意题目是按照原树的层序，输出每一层叶节点的个数，所以在转换成二叉树的时候要存放结点的层数。即：一个结点的左孩子的层数 = 该节点的层数+1，一个结点兄弟结点的层数 = 该节点的层数</p>
<p>　　最后遍历所有的结点，将每一层叶节点的数目存放在count数组中。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a><font color=#0099ff size=4 face="黑体">注意事项:</font></h1><ol>
<li>更新结点层数的同时要记录树的最大层数。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码:"></a><font color=#0099ff size=4 face="黑体">代码:</font></h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXI = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> lchild;</span><br><span class="line">    <span class="keyword">int</span> rsibling;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">    <span class="built_in">TNode</span>()&#123;</span><br><span class="line">        lchild = rsibling = <span class="number">-1</span>;</span><br><span class="line">        level = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Node[MAXI];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M, K, i, j, id;</span><br><span class="line">    <span class="keyword">int</span> idk[MAXI];</span><br><span class="line">    <span class="keyword">int</span> count[MAXI] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; M; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;id, &amp;K);</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; K; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;idk[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        Node[id].lchild = idk[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(j = K - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">            Node[idk[j<span class="number">-1</span>]].rsibling = idk[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max_level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Node[i].lchild != <span class="number">-1</span>)&#123;</span><br><span class="line">            Node[Node[i].lchild].level = Node[i].level + <span class="number">1</span>;</span><br><span class="line">            max_level = (max_level &gt;= Node[i].level + <span class="number">1</span>)? max_level: Node[i].level + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Node[i].rsibling != <span class="number">-1</span>)&#123;</span><br><span class="line">            Node[Node[i].rsibling].level = Node[i].level;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Node[i].lchild == <span class="number">-1</span>)&#123;</span><br><span class="line">            count[Node[i].level]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, count[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= max_level; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, count[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
        <category>PAT</category>
        <category>Advanced</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT (甲级) 1042 Shuffling Machine (20分)</title>
    <url>//1042.html</url>
    <content><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题:"></a><font color=#0099ff size=4 face="黑体">原题:</font></h1><p>Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid “inside jobs” where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ automatic shuffling machines. Your task is to simulate a shuffling machine.</p>
<p>The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S1, S2, ..., S13, </span><br><span class="line">H1, H2, ..., H13, </span><br><span class="line">C1, C2, ..., C13, </span><br><span class="line">D1, D2, ..., D13, </span><br><span class="line">J1, J2</span><br></pre></td></tr></table></figure>
<p>where “S” stands for “Spade”, “H” for “Heart”, “C” for “Club”, “D” for “Diamond”, and “J” for “Joker”. A given order is a permutation of distinct integers in [1, 54]. If the number at the i-th position is j, it means to move the card from position i to position j. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13.</p>
<p><font size=4>Input Specification:</font></p>
<p>Each input file contains one test case. For each case, the first line contains a positive integer K (≤20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space.</p>
<p><font size=4>Output Specification:</font></p>
<p>For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line.</p>
<p><font size=4>Sample Input:</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">36 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47</span><br></pre></td></tr></table></figure>
<p><font size=4>Sample Output:</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a><font color=#0099ff size=4 face="黑体">题目大意:</font></h1><p>　　给定次数和一个序列。按序打乱一副扑克牌。</p>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类:"></a><font color=#0099ff size=4 face="黑体">分类:</font></h1><p>　　简单模拟</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路:"></a><font color=#0099ff size=4 face="黑体">思路:</font></h1><p>　　最初没有深入思考直接按照题目要求去做，构建了两个字符串数组cards（存放排序前的序列），cards2（存放排序后的序列）。这种做法的问题在于需要去额外生成表示扑克牌的字符串数组，而且每次打乱顺序处理的都是字符串，比价麻烦。</p>
<p>　　后来考虑用两个数组start（排序前的序列），end（排序后的序列）直接表示该位置是第几张牌。这样每次处理的是位置信息，而且不需要额外表示每张扑克牌。只需要最后输出的时候根据第i张牌，来判断i所对应的扑克牌的字符串表示。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a><font color=#0099ff size=4 face="黑体">注意事项:</font></h1><ol>
<li><p>输出格式，最后一个数据后面无空格</p>
</li>
<li><p>输入的数据表示的是第i张牌，存放在数组的索引应该是i-1</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码:"></a><font color=#0099ff size=4 face="黑体">代码:</font></h1><p>方法1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用字符串数组存放序列</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i, j;</span><br><span class="line">    <span class="keyword">int</span> order[<span class="number">54</span>];</span><br><span class="line">    string cards[<span class="number">54</span>];</span><br><span class="line">    string cards2[<span class="number">54</span>];</span><br><span class="line">    string s = <span class="string">&quot;SHCD&quot;</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">54</span>; i++)&#123;</span><br><span class="line">        cin &gt;&gt; order[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成字符串数组</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; <span class="number">14</span>; j++)&#123;</span><br><span class="line">            cards[i*<span class="number">13</span> + j - <span class="number">1</span>] = s[i] + <span class="built_in">to_string</span>(j); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cards[<span class="number">52</span>] = <span class="string">&quot;J1&quot;</span>;</span><br><span class="line">    cards[<span class="number">53</span>] = <span class="string">&quot;J2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">54</span>; j++)&#123;</span><br><span class="line">            cards2[order[j]<span class="number">-1</span>] = cards[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">54</span>; j++)&#123;</span><br><span class="line">            cards[j] = cards2[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">53</span>; i++)&#123;</span><br><span class="line">        cout &lt;&lt; cards2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cards2[<span class="number">53</span>];</span><br><span class="line">    <span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用位置信息处理</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">54</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">5</span>] = &#123;<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;J&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i, j;</span><br><span class="line">    <span class="keyword">int</span> start[N], end[N], order[N];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        start[i] = i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;order[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; N; j++)&#123;</span><br><span class="line">            end[order[j]<span class="number">-1</span>] = start[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; N; j++)&#123;</span><br><span class="line">            start[j] = end[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c%d&quot;</span>, s[end[i]/<span class="number">13</span>], end[i]%<span class="number">13</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(i != N - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
        <category>PAT</category>
        <category>Advanced</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT (甲级) 1025 PAT Ranking (25分)</title>
    <url>//1025.html</url>
    <content><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题:"></a><font color=#0099ff size=4 face="黑体">原题:</font></h1><p>Programming Ability Test (PAT) is organized by the College of Computer Science and Technology of Zhejiang University. Each test is supposed to run simultaneously in several places, and the ranklists will be merged immediately after the test. Now it is your job to write a program to correctly merge all the ranklists and generate the final rank.</p>
<p><font size=4>Input Specification:</font></p>
<p>Each input file contains one test case. For each case, the first line contains a positive number N (≤100), the number of test locations. Then N ranklists follow, each starts with a line containing a positive integer K (≤300), the number of testees, and then K lines containing the registration number (a 13-digit number) and the total score of each testee. All the numbers in a line are separated by a space.</p>
<p><font size=4>Output Specification:</font></p>
<p>For each test case, first print in one line the total number of testees. Then print the final ranklist in the following format:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">registration_number final_rank location_number local_rank</span><br></pre></td></tr></table></figure>

<p>The locations are numbered from 1 to N. The output must be sorted in nondecreasing order of the final ranks. The testees with the same score must have the same rank, and the output must be sorted in nondecreasing order of their registration numbers.</p>
<p><font size=4>Sample Input:</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">5</span><br><span class="line">1234567890001 95</span><br><span class="line">1234567890005 100</span><br><span class="line">1234567890003 95</span><br><span class="line">1234567890002 77</span><br><span class="line">1234567890004 85</span><br><span class="line">4</span><br><span class="line">1234567890013 65</span><br><span class="line">1234567890011 25</span><br><span class="line">1234567890014 100</span><br><span class="line">1234567890012 85</span><br></pre></td></tr></table></figure>

<p><font size=4>Sample Output:</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">1234567890005 1 1 1</span><br><span class="line">1234567890014 1 2 1</span><br><span class="line">1234567890001 3 1 2</span><br><span class="line">1234567890003 3 1 2</span><br><span class="line">1234567890004 5 1 4</span><br><span class="line">1234567890012 5 2 2</span><br><span class="line">1234567890002 7 1 5</span><br><span class="line">1234567890013 8 2 3</span><br><span class="line">1234567890011 9 2 4</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a><font color=#0099ff size=4 face="黑体">题目大意:</font></h1><p>　　PAT考试，有N个考场，每个考场有不同的学生。现给出每个考场中学生的准考证号和分数，要求对学生按分数从高到低排序，并输出考生的准考证号、排名、考场编号、考场内排名。</p>
<h1 id="题目分类"><a href="#题目分类" class="headerlink" title="题目分类:"></a><font color=#0099ff size=4 face="黑体">题目分类:</font></h1><p>　　排序</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路:"></a><font color=#0099ff size=4 face="黑体">思路:</font></h1><p>　　构建结构体存放学生信息，利用sort函数，编写排序函数cmp方法进行排序。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a><font color=#0099ff size=4 face="黑体">注意事项:</font></h1><ol>
<li>排序函数cmp的编写：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(ranklist a, ranklist b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score != b.score) <span class="keyword">return</span> a.score &gt; b.score; <span class="comment">//分数从高到低</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">strcmp</span>(a.reg_num, b.reg_num) &lt; <span class="number">0</span>; <span class="comment">//准考证号从小到大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也要注意sort函数的范围是前闭后开，即[start,end)</p>
<ol start="2">
<li>排名的实现。</li>
</ol>
<p>　　排名的规则是<strong>不同分数排名不同，相同分数排名相同但每一个都占用一个排名位置</strong></p>
<p>　　具体实现：遍历每个个体，若当前个体分数与上一个分数相同，则两个排名相同；若分数不同，则其排名等于数组下标+1（数组下标需表示个体在总体中的位置）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(j = start + <span class="number">1</span>; j &lt; end; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(list[j].score == list[j - <span class="number">1</span>].score) &#123;</span><br><span class="line">        list[j].local_rank = list[j - <span class="number">1</span>].local_rank;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        list[j].local_rank = j - start + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码:"></a><font color=#0099ff size=4 face="黑体">代码:</font></h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUM 30000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ranklist</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> location_number; <span class="comment">//考场号</span></span><br><span class="line">    <span class="keyword">int</span> score; <span class="comment">//分数</span></span><br><span class="line">    <span class="keyword">int</span> local_rank; <span class="comment">//考场内排名</span></span><br><span class="line">    <span class="keyword">char</span> reg_num[<span class="number">14</span>]; <span class="comment">//准考证号</span></span><br><span class="line">&#125;list[MAX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(ranklist a, ranklist b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score != b.score) <span class="keyword">return</span> a.score &gt; b.score; <span class="comment">//分数从高到低</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">strcmp</span>(a.reg_num, b.reg_num) &lt; <span class="number">0</span>; <span class="comment">//准考证号从小到大</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, N, K, idx=<span class="number">0</span>, start, end=<span class="number">0</span>, rank = <span class="number">1</span>; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;K);</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; K; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>, &amp;list[idx].reg_num, &amp;list[idx].score);</span><br><span class="line">            list[idx].location_number = i + <span class="number">1</span>;</span><br><span class="line">            list[idx].local_rank = <span class="number">-1</span>;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        start = end;</span><br><span class="line">        end = idx;</span><br><span class="line">        <span class="built_in">sort</span>(list + start, list + end, cmp);</span><br><span class="line">        list[start].local_rank = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = start + <span class="number">1</span>; j &lt; end; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list[j].score == list[j - <span class="number">1</span>].score) &#123;</span><br><span class="line">                list[j].local_rank = list[j - <span class="number">1</span>].local_rank;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                list[j].local_rank = j - start + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(list, list + idx, cmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, idx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%s %d %d %d&quot;</span>, list[<span class="number">0</span>].reg_num, rank, list[<span class="number">0</span>].location_number, list[<span class="number">0</span>].local_rank);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; idx; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list[i].score != list[i - <span class="number">1</span>].score)&#123;</span><br><span class="line">            rank = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%s %d %d %d&quot;</span>, list[i].reg_num, rank, list[i].location_number, list[i].local_rank);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
        <category>PAT</category>
        <category>Advanced</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT (甲级) 1070 PAT Mooncake (25分)</title>
    <url>//1070.html</url>
    <content><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题:"></a><font color=#0099ff size=4 face="黑体">原题:</font></h1><p>Mooncake is a Chinese bakery product traditionally eaten during the Mid-Autumn Festival. Many types of fillings and crusts can be found in traditional mooncakes according to the region’s culture. Now given the inventory amounts and the prices of all kinds of the mooncakes, together with the maximum total demand of the market, you are supposed to tell the maximum profit that can be made.</p>
<p>Note: partial inventory storage can be taken. The sample shows the following situation: given three kinds of mooncakes with inventory amounts being 180, 150, and 100 thousand tons, and the prices being 7.5, 7.2, and 4.5 billion yuans. If the market demand can be at most 200 thousand tons, the best we can do is to sell 150 thousand tons of the second kind of mooncake, and 50 thousand tons of the third kind. Hence the total profit is 7.2 + 4.5/2 = 9.45 (billion yuans).</p>
<p><font size=4>Input Specification:</font></p>
<p>Each input file contains one test case. For each case, the first line contains 2 positive integers N (≤1000), the number of different kinds of mooncakes, and D (≤500 thousand tons), the maximum total demand of the market. Then the second line gives the positive inventory amounts (in thousand tons), and the third line gives the positive prices (in billion yuans) of N kinds of mooncakes. All the numbers in a line are separated by a space.</p>
<p><font size=4>Output Specification:</font></p>
<p>For each test case, print the maximum profit (in billion yuans) in one line, accurate up to 2 decimal places.</p>
<p><font size=4>Sample Input</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 200</span><br><span class="line">180 150 100</span><br><span class="line">7.5 7.2 4.5</span><br></pre></td></tr></table></figure>

<p><font size=4>Sample Output</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9.45</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a><font color=#0099ff size=4 face="黑体">题目大意:</font></h1><p>　　给定N种月饼的库存数量和总价，以及市场需要的月饼总量D。判断售卖月饼可以获得的最大利润。</p>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类:"></a><font color=#0099ff size=4 face="黑体">分类:</font></h1><p>　　贪心</p>
<h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路:"></a><font color=#0099ff size=4 face="黑体">题目思路:</font></h1><p>　　算是一种简单的贪心算法。想要求得最大利润，就要优先考虑单价最高的月饼。所以：</p>
<ol>
<li><p>计算每种月饼的单价，并按降序排列。遍历月饼序列</p>
</li>
<li><p>如果该月饼库存 &lt; 市场需求量，更新总收益、市场需求量</p>
<p>总收益 += 该月饼总价；</p>
<p>市场需求量 -= 该月饼总量；</p>
</li>
<li><p>如果该月饼库存 &gt; 市场需求量，则计算总收益并停止遍历</p>
<p>总收益 += 该月饼总价 * （市场需求量 / 月饼总量）</p>
</li>
</ol>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a><font color=#0099ff size=4 face="黑体">注意事项:</font></h1><ol>
<li><p>遍历月饼序列时要加判断i &lt; N，否则会越界错误</p>
</li>
<li><p>题中没有说月饼总量是int</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码:"></a><font color=#0099ff size=4 face="黑体">代码:</font></h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单贪心</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mooncake</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> amount; <span class="comment">//月饼总量</span></span><br><span class="line">    <span class="keyword">float</span> price; <span class="comment">//价格</span></span><br><span class="line">    <span class="keyword">float</span> price_per; <span class="comment">//单价</span></span><br><span class="line">&#125;mc[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(mooncake a, mooncake b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.price_per &gt; b.price_per;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, N; <span class="keyword">float</span> D;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %f&quot;</span>, &amp;N, &amp;D);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;mc[i].amount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;mc[i].price);</span><br><span class="line">        mc[i].price_per = mc[i].price / mc[i].amount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(mc, mc + N, cmp);</span><br><span class="line">    <span class="keyword">float</span> max_profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; D - mc[i].amount &gt;= <span class="number">0</span> &amp;&amp; i &lt; N; i++)&#123;</span><br><span class="line">        max_profit += mc[i].price;</span><br><span class="line">        D -= mc[i].amount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i != N)&#123;    </span><br><span class="line">        max_profit += mc[i].price * D / mc[i].amount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>, max_profit);</span><br><span class="line">    <span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
        <category>PAT</category>
        <category>Advanced</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT (甲级) 1099 Build A Binary Search Tree (30分)</title>
    <url>//1099.html</url>
    <content><![CDATA[<h1 id="原题"><a href="#原题" class="headerlink" title="原题:"></a><font color=#0099ff size=4 face="黑体">原题:</font></h1><p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys less than the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p>Given the structure of a binary tree and a sequence of distinct integer keys, there is only one way to fill these keys into the tree so that the resulting tree satisfies the definition of a BST. You are supposed to output the level order traversal sequence of that tree. The sample is illustrated by Figure 1 and 2.</p>
<p><img src="https://images.ptausercontent.com/24c2521f-aaed-4ef4-bac8-3ff562d80a1b.jpg"></p>
<p><font size=4>Input Specification:</font></p>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤100) which is the total number of nodes in the tree. The next N lines each contains the left and the right children of a node in the format <font color=pink>left_index right_index</font>, provided that the nodes are numbered from 0 to N−1, and 0 is always the root. If one child is missing, then −1 will represent the NULL child pointer. Finally N distinct integer keys are given in the last line.</p>
<p><font size=4>Output Specification:</font></p>
<p>For each test case, print in one line the level order traversal sequence of that tree. All the numbers must be separated by a space, with no extra space at the end of the line.</p>
<p><font size=4>Sample Input:</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">1 6</span><br><span class="line">2 3</span><br><span class="line">-1 -1</span><br><span class="line">-1 4</span><br><span class="line">5 -1</span><br><span class="line">-1 -1</span><br><span class="line">7 -1</span><br><span class="line">-1 8</span><br><span class="line">-1 -1</span><br><span class="line">73 45 11 58 82 25 67 38 42</span><br></pre></td></tr></table></figure>

<p><font size=4>Sample Output:</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">58 25 82 11 38 67 45 73 42</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a><font color=#0099ff size=4 face="黑体">题目大意:</font></h1><p>　　给定一个二叉搜索树（BST）的结构和一组输入序列，将输入序列填到BST对应的位置，然后按层序遍历的顺序输出结果。</p>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类:"></a><font color=#0099ff size=4 face="黑体">分类:</font></h1><p>　　二叉树</p>
<h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路:"></a><font color=#0099ff size=4 face="黑体">题目思路:</font></h1><p>　　使用结构数组静态的表示二叉搜索树，然后将输入序列从小到大排序，这对应BST的中序遍历。将排序好的输入序列，按照BST中序遍历的顺序，放到对应的结点，最后按照层序遍历的顺序输出序列。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a><font color=#0099ff size=4 face="黑体">注意事项:</font></h1><ol>
<li>最后输出的结果最后一个数据后面不能有空格，所以不能直接在层序遍历的时候输出结果。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码:"></a><font color=#0099ff size=4 face="黑体">代码:</font></h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXI = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">//中序遍历时用来确定结点对应数组d的值</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> lchild;</span><br><span class="line">    <span class="keyword">int</span> rchild;</span><br><span class="line">&#125;Node[MAXI];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[MAXI], result[MAXI]; <span class="comment">//输入序列， 中序遍历输出序列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mid_order</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mid_order</span>(Node[root].lchild);</span><br><span class="line">    Node[root].data = d[index++];</span><br><span class="line">    <span class="built_in">mid_order</span>(Node[root].rchild);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layer_order</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Queue[MAXI];</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>, root, i = <span class="number">0</span>;</span><br><span class="line">    Queue[rear++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (rear &gt; front)&#123;</span><br><span class="line">        root = Queue[front++];</span><br><span class="line">        <span class="comment">//printf(&quot;%d &quot;, Node[root].data);</span></span><br><span class="line">        result[i++] = Node[root].data;</span><br><span class="line">        <span class="keyword">if</span>(Node[root].lchild != <span class="number">-1</span>)&#123;</span><br><span class="line">            Queue[rear++] = Node[root].lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Node[root].rchild != <span class="number">-1</span>)&#123;</span><br><span class="line">            Queue[rear++] = Node[root].rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n, l_index, r_index;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l_index, &amp;r_index);</span><br><span class="line">        Node[i].lchild = l_index;</span><br><span class="line">        Node[i].rchild = r_index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(d, d+n);</span><br><span class="line">    <span class="built_in">mid_order</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">layer_order</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, result[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, result[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
        <category>PAT</category>
        <category>Advanced</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
</search>
